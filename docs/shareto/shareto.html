<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="manifest" href="manifest.json" crossorigin="use-credentials">
	<link rel="stylesheet" href="shareto.css">
	<script src="storage.js"></script>
	<script src="common.js"></script>
	<script src="version.js"></script>
	<script>
		let swCacheName;
		try {
			console.clear();
			if ('serviceWorker' in navigator && (location.protocol === "https:" || location.hostname === "localhost")) {
				window.addEventListener("load", () => {
					navigator.serviceWorker.register('sw.js')
						.then(reg => {
							console.log("Service worker registered");
							navigator.serviceWorker.addEventListener("message", (event) => {
								if (event.type == "message") {
									if (event.data.name) {
										swCacheName = event.data.name;
										if (swCacheName !== cacheName) {
											reg.update();
											console.log(swCacheName, cacheName, "Service worker updated");
										}
									}
								}
							});
							reg.active.postMessage("name");
						})
						.catch(err => console.error(`Service Worker Error: ${err}`));
				});
			}
		} catch (e) {
			console.error(e);
		}			
	</script>
</head>

<body>
	<div id="subfrom">
		<div>Title (<span id="info"></span><a id="revert" href="#"> revert</a>)</div>
		<textarea id="title" wrap="soft" style="width: 90vw; height: 20vh;"></textarea>
		<div>Url (<a id="link" href="#">open</a>
			<a id="combine" href="#">combine</a>)
		</div>
		<textarea id="url" wrap="soft" style="width: 90vw; height: 20vh;"></textarea>
		<div id="buts"></div>
		<div><input id="toqueue" type="button" style="background-color: bisque;"></div>
	</div>

	<script type="text/javascript">
		//console.clear();
		const tick = " âœ”"; // &#10003;";
		const page = {};
		const all = document.querySelectorAll("*[id]");
		all.forEach((val) => {
			page[val.id] = val;
		});
		let storage = new CbStorage("shareto");
		let dests = storage.require("destinations", []);
		let history = storage.require("history", {});
		let histAge = storage.require("histAge", []);
		let histhash;
		page.buts.innerHTML = "";
		let newWin = false;

		let search = Object.fromEntries(new URLSearchParams(location.hash.replace("#", "?")));
		console.log(location);
		if (search.history === undefined) {
			page.title.value = search.name ?? "";
			page.url.value = search.description ?? "";
			histhash = generateHash(page.url.value);
			let histAgeIndex = histAge.lastIndexOf(histhash);
			if (histAgeIndex !== -1) {
				histAge.splice(histAgeIndex, 1);
			}
			history[histhash] = {title: page.title.value, url: page.url.value};
			histAge.unshift(histhash);
			while (histAge.length > 100) {
				let key = histAge.pop();
				delete history[key];
			}
			storage.save();

		} else {
			let item = history[search.history];
			if (item !== undefined) {
				page.title.value = item.title ?? "";
				page.url.value = item.url ?? "";
				histhash = search.history;
			}
		}
		applyEdits();

		dests.forEach(dest => {
			let inp = document.createElement("input");
			let newWin = false;
			inp.type = "button";
			destinationSet(inp, dest.name);
			inp.onclick = e => {
				let loc = dest.url.replace("$title", encodeURIComponent(page.title.value)).replace("$url", encodeURIComponent(page.url.value));
				try {
					let url = new URL(loc);
					console.log(loc);
					if (!url.protocol.startsWith("http")) {
						throw ("Not http/s");
					}
					if (destinationClick(e, inp, dest.name)) {
						if (newWin) {
							window.open(loc, '_blank').focus();
						} else {
							location = loc;
						}
					}
				} catch (e) {
					alert("Not a valid URL '" + loc + "'");
				}
			}
			buts.appendChild(inp);
		});

		destinationSet(page.toqueue, "Queue")


		page.title.oninput = page.url.oninput = e => {
			let item = history[histhash];
			page.revert.style.display = "none";
			if (page.title.value !== item.title || page.url.value !== item.url){
				page.revert.style.display = "inline";
				if (item !== undefined) {
					revert.onclick = e => {
						page.title.value = item.title;
						page.url.value = item.url;
						page.revert.style.display = "none";
					}
				}
			}
			page.info.innerHTML = page.title.value.length;
		}

		page.title.oninput();

		page.toqueue.onclick = e => {
			destinationClick(e, page.toqueue, "Queue");
		}

		page.link.onclick = e => {
			e.preventDefault();
			if (!page.url.value) {
				return;
			}
			let url = new URL(page.url.value); //Fail if invalid
			if (!url.protocol.startsWith("http")) {
				throw ("Not http/s");
			}
			location = page.url.value;
		}

		page.combine.onclick = e => {
			e.preventDefault();
			page.title.value = page.title.value + "\n\n" + page.url.value;
		}

		function applyEdits() {
			let edits = storage.getItem("edits");
			if (!edits) {
				return;
			}
			//Auto remove
			if (edits.artitle) {
				edits.artitle.forEach(str => {
					page.title.value = page.title.value.replace(str, "");
				});
				page.title.value = page.title.value.replace("  ", " ");
			}
			if (edits.arurl) {
				edits.arurl.forEach(str => {
					page.url.value = page.url.value.replace(str, "");
				});
				page.url.value = page.url.value.replace("  ", " ");
			}
		}

		function destinationClick(e, inp, name) {
			e.preventDefault();
			if (histhash) {
				let item = history[histhash];
				if (item !== undefined) {
					if (item[name]) {
						delete item[name];
						storage.save();
						inp.value = "Send to " + name + "    ";
						return false;
					}
					item[name] = true;
					inp.value = "Send to " + name + tick;
					storage.save();
				}
				return true;
			}
			return false;
		}

		function destinationSet(inp, name) {
			if (histhash) {
				let item = history[histhash];
				if (item !== undefined) {
					if (item[name]) {
						inp.value = "Send to " + name + tick;
					} else {
						inp.value = "Send to " + name + "    ";
					}
				}
			} else {
				inp.value = "Send to " + name + "    ";
			}
		}

		function generateHash(string) {
			let hash = 0;
			for (const char of string) {
				hash = (hash << 5) - hash + char.charCodeAt(0);
				hash |= 0; // Constrain to 32bit integer
			}
			return hash;
		};

	</script>

</body>

</html>